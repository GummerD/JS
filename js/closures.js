// как функции обращаются к переменным

let x = 10;

function f_1() {
    console.log(`Глобальняа переменная, к котрой обратилась функция ${x}`);
}

f_1();

function f_2() {
    let x = 99 // внутри функции обязательно определяем новую переменную через let/var/const 
    // чтобы функция не взяла ее из глобального поля и не переопределила
    console.log(`Локальная переменная, к котрой обратилась функция ${x}`);
}

//данная переменная спрятана или замкнута внутри функции

f_2();

let count = 0;

function f_3() {
    count++;
    console.log(count);
}

f_3();
f_3();
f_3();
f_3();
f_3();

//иногда необходимо, чтобы переменная былаглобальной

function step() {
    count++
    console.log(count + 1);
}

step();
step();
step();
step();
step();

// при помещение переменной внутрь функции, при каждом вызове переменная бдет создваться занова. 

//функция, в котрую вложена переменная:
function step_2() {
    let count = 0;
    count++
    console.log(count);
}

step_2()
step_2()
step_2()
step_2()
step_2()
// в итоге результат в этом случае всегда будет один - 1;
// но можно сделать так, чтобы переменная была определеная для конкретной ффункции
// не входя в глобальную область видимости

// для этого необходимо обернуть функцию другой функцией:

function func_wrapper() {
    let count = 0;
    return function step() {
        count++;
        console.log("Вызывается 1 функцией-оберткой: " + count);
    }
}

let func_hendler = func_wrapper();
func_hendler();
func_hendler();
func_hendler();
func_hendler();
func_hendler();

// функцию, которая находится внутри "обертки" имеет смысл делать анонимной, название там не играет роли

function func_wrapper_2() {
    let count = 0;
    return function () {
        count++;
        console.log("Вызывается 2 функцией-оберткой анонимную функцию: " + count);
    }
}

let func_hendler_2 = func_wrapper_2();
func_hendler_2();
func_hendler_2();
func_hendler_2();
func_hendler_2();
func_hendler_2();
// очень полезный способ использовать замыкание заключается в потоврном его использовании:
console.log("Вторая обертка")
let func_hendler_3 = func_wrapper_2();
func_hendler_3();
func_hendler_3();
func_hendler_3();
// эти блоки независимы друг от друга со своей областью видимости
//-----------------------------------------------------------------------
// в итоге замыкание - это прием программирования, когда создается функция, внутри которй помещаются нужные данные и способы манипулирования
// этими данными (другая функция), прив ыполнении обетки пораждается область внури нее (замкнутая область)
// большая польза такого примеа - создание своей изолированной зоны со своими переменными и функциями,
// которые не пересекаются с переменными глобальной области видимости

// для замкнутых областей видимости актально все то, что и для обычнх функци (аргументы и т.д.)
console.log("Третья обертка");

function func_wrapper_3(n = 0) {
    let count = n;
    return function () {
        count++;
        console.log("Вызывается 3 функцией-оберткой анонимную функцию: " + count);
    }
}

let func_hendler_4 = func_wrapper_3(500);
func_hendler_4();
func_hendler_4();
func_hendler_4();

// Новый пример с кошельком на зацикливании

function randomMoney() {
    return Math.floor(Math.random() + 15 / (Math.random()));
}

console.log("Кошелек");

function pushWallet() {
    let money = randomMoney();
    let wallet = 0;
    console.log(wallet + " - перменная wallet в обертки"); 
    return function getMoney() {
        wallet += money;
        console.log(wallet + "функция внутри обертки");  
        if (wallet >= 500) return wallet;
        getMoney() 
    }
    
}

let searchWallet = pushWallet();
// странная ситуация с получением значения из функции обертки
console.log(searchWallet() + " тут нет? почему? значение ниже");

let money =  searchWallet();

console.log(money + 'тут');

// к html файлу подключено еще два файла closures_a and closures_b
// в них есть две переменные p and p соответственно в этом файле объявлена переменная p

let p ;

// получается. что при использовании этих перемнных в единм пространестве они зависимы друг
// от друга, получаемый результат над ним становится един для всех.
// в файлах a и  b мы повесили на две кнопки querySelector, и функции onclick
// которые получают сумму для p, и на текущий момент все становится зависмым.
// и для того чтобы решить ситуацию с перемешанными данными или саязанными переменными
// код лучше всего всегда писать на замыканиях
